// Code generated by util/generateJsonDatasources; DO NOT EDIT.
package json

import (
	"context"
	"encoding/json"
	"errors"
	"reflect"
  "strings"

  "golang.org/x/text/cases"
  "golang.org/x/text/language"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	netbox "github.com/smutel/go-netbox/v4"
	"github.com/smutel/terraform-provider-netbox/v8/netbox/internal/util"
)

// This file was generated by the util/generateJsonDatasources.
// Editing this file might prove futile when you re-run the util/generateJsonDatasources command

func DataNetboxJSONDcimInventoryItemRolesList() *schema.Resource {
	return &schema.Resource{
		Description: "Get json output from the DcimInventoryItemRolesList Netbox endpoint.",
		ReadContext: dataNetboxJSONDcimInventoryItemRolesListRead,

		Schema: map[string]*schema.Schema{
			"filter": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "Filter the records returned by the query.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Name of the field to use for filtering.",
						},
						"value": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Value of the field to use for filtering. " +
                "You can use comma separated values as AND operator.",
						},
					},
				},
			},
			"limit": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     0,
				Description: "The max number of returned results. If 0 is specified, all records will be returned.",
			},
			"json": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "JSON output of the list of objects for this Netbox endpoint.",
			},
		},
	}
}

func dataNetboxJSONDcimInventoryItemRolesListRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*netbox.APIClient)

  limit := int32(d.Get("limit").(int))
  request := client.DcimAPI.DcimInventoryItemRolesList(ctx)

	if filter, ok := d.GetOk("filter"); ok {
		var filterParams = filter.(*schema.Set)
		for _, f := range filterParams.List() {
			k := f.(map[string]any)["name"]
			v := f.(map[string]any)["value"]
			kString := k.(string)
      kString = cases.Title(language.Und).String(kString)
			vString := strings.Split(v.(string), ",")
      inputs := make([]reflect.Value, 1)
      inputs[0] = reflect.ValueOf(vString)
      method := reflect.ValueOf(request).MethodByName(kString)
      if ! reflect.ValueOf(method).IsZero() {
        result := method.Call(inputs)
        request = result[0].Interface().(netbox.ApiDcimInventoryItemRolesListRequest)
      } else {
		    return util.GenerateErrorMessage(nil, errors.New(
          "Filter " + kString + " not found. " +
			    "Please change the name of the filter."))
      }
		}
	}

	resource, response, err := request.Execute()

	if err != nil {
		return util.GenerateErrorMessage(response, err)
	}

	if resource.GetCount() < 1 {
		return util.GenerateErrorMessage(nil, errors.New("Your query returned no results. "+
			"Please change your search criteria and try again."))
	}

	resources := resource.Results
  if limit < int32(len(resources)) && limit != 0 {
    resources = resources[:limit]
  }

	j, _ := json.Marshal(resources)

	if err = d.Set("json", string(j)); err != nil {
		return util.GenerateErrorMessage(response, err)
	}
	d.SetId("NetboxJSONDcimInventoryItemRolesList")

	return nil
}
