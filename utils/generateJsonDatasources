#!/bin/bash

SCRIPT_PATH=$(dirname "$0")

find "${SCRIPT_PATH}"/../netbox/json/ -name "*_json_*.go" -delete
rm -rf "${SCRIPT_PATH}"/../examples/data-sources/netbox_json_*

grep -ohR " Api[a-zA-Z]*List" "${SCRIPT_PATH}"/../vendor/github.com/smutel/go-netbox/v4 | sort -u | while read -r line; do
  line=$(echo "$line" | xargs)
  module=${line//Api/}

  if [ "$module" == "DcimConnectedDeviceList" ] || [[ "$module" == *Available* ]]; then
    continue
  fi
  moduleLower=$(echo "$module" | sed -E 's/([A-Z])/_\1/g' | sed 's/^_//g' | tr '[:upper:]' '[:lower:]')
  api=$(echo "$moduleLower" | cut -d"_" -f1)

cat << EOF > "${SCRIPT_PATH}"/../netbox/json/data_netbox_json_"${moduleLower}".go
// Code generated by util/generateJsonDatasources; DO NOT EDIT.
package json

import (
	"context"
	"encoding/json"
	"errors"
	"reflect"
  "strings"

  "golang.org/x/text/cases"
  "golang.org/x/text/language"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	netbox "github.com/smutel/go-netbox/v4"
	"github.com/smutel/terraform-provider-netbox/v8/netbox/internal/util"
)

// This file was generated by the util/generateJsonDatasources.
// Editing this file might prove futile when you re-run the util/generateJsonDatasources command

func DataNetboxJSON${module}() *schema.Resource {
	return &schema.Resource{
		Description: "Get json output from the ${module} Netbox endpoint.",
		ReadContext: dataNetboxJSON${module}Read,

		Schema: map[string]*schema.Schema{
			"filter": {
				Type:        schema.TypeSet,
				Optional:    true,
				Description: "Filter the records returned by the query.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Name of the field to use for filtering.",
						},
						"value": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Value of the field to use for filtering. " +
                "You can use comma separated values as AND operator.",
						},
					},
				},
			},
			"limit": {
				Type:        schema.TypeInt,
				Optional:    true,
				Default:     0,
				Description: "The max number of returned results. If 0 is specified, all records will be returned.",
			},
			"json": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "JSON output of the list of objects for this Netbox endpoint.",
			},
		},
	}
}

func dataNetboxJSON${module}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*netbox.APIClient)

  limit := int32(d.Get("limit").(int))
  request := client.${api^}API.${module}(ctx)

	if filter, ok := d.GetOk("filter"); ok {
		var filterParams = filter.(*schema.Set)
		for _, f := range filterParams.List() {
			k := f.(map[string]any)["name"]
			v := f.(map[string]any)["value"]
			kString := k.(string)
      kString = cases.Title(language.Und).String(kString)
			vString := strings.Split(v.(string), ",")
      inputs := make([]reflect.Value, 1)
      inputs[0] = reflect.ValueOf(vString)
      method := reflect.ValueOf(request).MethodByName(kString)
      if ! reflect.ValueOf(method).IsZero() {
        result := method.Call(inputs)
        request = result[0].Interface().(netbox.Api${module}Request)
      } else {
		    return util.GenerateErrorMessage(nil, errors.New(
          "Filter " + kString + " not found. " +
			    "Please change the name of the filter."))
      }
		}
	}

	resource, response, err := request.Execute()

	if err != nil {
		return util.GenerateErrorMessage(response, err)
	}

	if resource.GetCount() < 1 {
		return util.GenerateErrorMessage(nil, errors.New("Your query returned no results. "+
			"Please change your search criteria and try again."))
	}

	resources := resource.Results
  if limit < int32(len(resources)) && limit != 0 {
    resources = resources[:limit]
  }

	j, _ := json.Marshal(resources)

	if err = d.Set("json", string(j)); err != nil {
		return util.GenerateErrorMessage(response, err)
	}
	d.SetId("NetboxJSON${module}")

	return nil
}
EOF

cat << EOF >> "${SCRIPT_PATH}"/provider_update.txt
"netbox_json_${moduleLower}": json.DataNetboxJSON${module}(),
EOF

mkdir -p "${SCRIPT_PATH}"/../examples/data-sources/netbox_json_"${moduleLower}"

cat << EOF > "${SCRIPT_PATH}"/../examples/data-sources/netbox_json_"${moduleLower}"/data-source.tf
data "netbox_json_${moduleLower}" "test" {
  limit = 0
}

output "example" {
  value = jsondecode(data.netbox_json_${moduleLower}.test.json)
}
EOF
done

grep -v "netbox_json_" "${SCRIPT_PATH}"/../netbox/provider.go > "${SCRIPT_PATH}"/../netbox/provider.go.tmp
sed -Ei 's/DataSourcesMap: map\[string\]\*schema.Resource\{/DataSourcesMap: map\[string\]\*schema.Resource\{\nDATAJSON/g' "${SCRIPT_PATH}"/../netbox/provider.go.tmp
while read -r line; do
  sed -i "s/DATAJSON/$line\nDATAJSON/g" "${SCRIPT_PATH}"/../netbox/provider.go.tmp
done < "${SCRIPT_PATH}"/provider_update.txt
sed -i '/^DATAJSON$/d' "${SCRIPT_PATH}"/../netbox/provider.go.tmp
mv "${SCRIPT_PATH}"/../netbox/provider.go.tmp "${SCRIPT_PATH}"/../netbox/provider.go
go fmt "${SCRIPT_PATH}"/../netbox/provider.go > /dev/null
rm -f "${SCRIPT_PATH}"/provider_update.txt
rm -f "${SCRIPT_PATH}"/netbox_list_endpoints.txt
